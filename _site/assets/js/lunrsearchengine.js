
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "http://localhost:4000/about",
    "title": "Profile",
    "body": "Profile이름 : 강성준 Contact:  Email. rkdtjdwns916@gmail. com Introduce학교 전공 수업 중 데이터베이스와 OS 수업에 흥미를 느꼈습니다. 이들의 동작은 표면적으로 드러나진 않지만 가장 중요한 부분이라고 생각합니다. 백엔드 개발자는 이러한 저의 관심사와 적합하다고 생각하여 해당 분야로 외부 활동과 프로젝트들을 진행했습니다.  Education서강대학교: 컴퓨터공학 재학 2017. 02 ~ 2024. 02 (예정)  교내 Web 개발 학회 CNU 활동 Web 스터디 진행 및 기술 공유경희고등학교: 2014. 03 ~ 2017. 02 (졸업) 네이버 커넥트재단 &lt;부스트캠프 웹・모바일 7기&gt;: 네이버 커넥트재단에서 진행한 웹 풀스택 개발자 양성 과정 챌린지 과정 2022. 07. 18 ~ 2022. 08. 12  기초 CS 지식 심화학습 및 분야별 도메인 지식 학습 팀원들과의 개발문화 형성 및 의사소통 역량 강화멤버십 과정 2022. 08. 31 ~ 2022. 12. 16  8주간의 학습스프린트를 통한 문제 해결 역량 강화 현업 개발 프로세스를 활용한 6주간의 그룹프로젝트 코드 리뷰 및 기술 공유 발표 팀 오순도순과의 SleepyWoods 서비스 백엔드 부분 참여 삼성전자 DX부문 동계 대학생 S/W 알고리즘 역량 강화 특강: 삼성전자에서 진행한 알고리즘 역량 강화 과정 알고리즘 2022. 01. ~ 2022. 02.  S/W 자료구조 및 알고리즘 심화 학습 알고리즘 문제 풀이 및 문제 해결 특강 ProjectSleepyWoods: Phaser, Socket 및 WebRTC로 즐기는 웹 기반 소셜 게임 프로젝트 Backend 2022. 11. ~ 2022. 12  JWT Payload를 활용한 유저 인증 시스템 구축, DB 조회 최소화 및 성능 개선 이벤트 기반 서버의 아키텍쳐 설계 및 유지보수성 향상 Socket 서버 최적화를 통한 유저 간의 끊김 없는 상호 기능 WebRTC를 활용한 실시간 화상 통화 지원 GitHub 바로가기 Tech StacksBackend  NestJS Express Spring BootDatabase  PostgreSQL, MySQL MongoDB, Mongoose Prisma ,TypeORMInfra  Naver Cloud Aws NginxFrontend  HTML/CSS (SASS, SCSS)"
    }, {
    "id": 2,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                           Selenium을 이용한 동적 크롤링                              :               회사에서 필요한 데이터를 수집 및 가공하는 과정에서 python으로 크롤링을 하게된 적이 있었다. 이 때 다양한 문제들을 접할 수 있었는데, 그 과정에서 얻어낸 정보들을 정리하기로 결심했다. . . . :                                                                                                                                                                       stouter                                15 Jan 2023                                                                                                                                        All Stories:                                                             [Nestjs] Socket Server에서 disconnect 감지하기              :       부스트캠프에서 팀원들과 SleepyWoods라는 실시간 WebSocket 서비스를 만들었을 때, Socket. io를 사용했었다. 이번 글에서는 간단하게 클라이언트의 disconnect를 감지하는 부분을 구현해보자. :                                                                               stouter                24 Dec 2022                                                                                            [Nestjs] 정적 모듈에서의 환경변수 사용              :       NestJS에서는 dotenv 등의 외부 라이브러리가 아닌 내장된 ConfigModule를 통해 환경 변수를 접근할 수 있도록 해주는데. . env 파일을 삽입해두면 하위 모듈에서 이를 process. env 식으로 접근하여 환경 변수를 사용할 수 있다. :                                                                               stouter                23 Dec 2022                                                                                                                                    부스트캠프 웹·모바일 7기 회고              :       약 5달간의 여정이 끝났다. 웹에 관해 아는 것이 전혀 없던 내가 어떻게 두려움도 없이 이 곳에 올 선택을 할 수 있었을까. 부스트캠프에 지원하기로 했던 결심은 내 개발 인생에서 가장 크고. . . :                                                                               stouter                21 Dec 2022                                            "
    }, {
    "id": 4,
    "url": "http://localhost:4000/selenium-crawling/",
    "title": "Selenium을 이용한 동적 크롤링",
    "body": "2023/01/15 - 회사에서 필요한 데이터를 수집 및 가공하는 과정에서 python으로 크롤링을 하게된 적이 있었다. 이 때 다양한 문제들을 접할 수 있었는데, 그 과정에서 얻어낸 정보들을 정리하기로 결심했다.  ⚠️ 해당 사이트가 정보 수집에 관하여 열려있는 지 우선 확인하자. robots. txt를 참조하면 해당 사이트의 정책 및 권한을 확인할 수 있다. 또한 잦은 크롤링은 해당 서비스에 부하를 줄 수 있으므로 내가 찾으려는 정보가 API 식으로 제공이 되는 지 또한 확인해보자.  크롤링 준비: 크롤링을 하기 전에 환경을 먼저 구성하자. 본인의 크롤링 상황에 적합한 라이브러리를 선택하고 확장성을 고려하자.  가상 환경 VS 로컬: 반드시 가상 환경에서 크롤링을 진행할 필요는 없다. 그렇지만 필자는 다음과 같은 이유로 크롤링을 위한 가상 환경을 준비한다.  크롤링을 하는 동안, 다른 작업을 하기 껄끄러울 수 있다.      이전에 처리해야할 데이터가 너무 많아 로컬에서 Multi-Processing을 진행했더니, 다른 작업을 하기 어려웠다.     프로젝트 의존성 같은 걸 고려하지 않아도 된다.      혹 나 말고도 다른 팀원들이 사용할 코드라면, 가상 환경에 프로젝트를 설정해두는 것이 사용에 편리할 수 있다.     혹 접근이 차단될 수도 있다…필자는 여러 크롤링 과정에서 다음과 같은 도구들을 활용했다.  Google Colab     구글에서 제공하는 도구로 Jupyter Notebook 실행을 위한 가상 환경을 제공한다. 무료로 이용할 수 있으며 약간 불편한 점도 있으나, 본인의 프로젝트가 간단한 것이라면 Colab 또한 좋은 접근성과 편리성을 제공한다.     Cloud Server     마침 Naver Cloud에 남은 credit이 있어 서버 인스턴스를 열어 크롤링을 한 적이 있다. 당시에 시간 요금제로 짧고 굵게 크롤링을 할 수 있었다.    Selenium: 크롤링 방법들을 찾아보다 보면 매우 자주 보이는 라이브러리이다. Selenium은 웹 어플리케이션을 테스트하기 위한 자동화 도구라고 한다. 그렇지만 크롤링에 있어 매우 유용한 라이브러리다.  Selenium의 필요성: 만약 크롤링하려는 페이지가 단순히 정적 HTML을 제공한다던가, 내가 원하는 정보가 해당 페이지의 HTML에 직접적으로 적혀 있다면 Selenium을 사용할 필요가 없다. 그렇다면 BeautifulSoup 과 같은 HTML Parsing 라이브러리를 통해 더 쉽고 빠르게 정보를 가져올 수 있다. 그치만 대부분의 경우엔 내가 수집하려는 정보가 비동기로 호출되거나, 특정 인터랙션을 통해 생성되는 정보일 것이다. 그렇다면 단순히 해당 페이지의 HTML을 가져오는 것으로는 정보를 추출할 수 없다. 이럴 때 사용되는 라이브러리가 Selenium이며, Selenium을 통해 브라우저를 마치 내가 직접 사이트를 이용하는 것 처럼 인간적이게(?) 크롤링을 시킬 수 있다.  Selenium 준비: 우선 Selenium으로 구동시킬 브라우저를 준비하자. 나는 이번 프로젝트에 Chrome 브라우저를 사용했으며, 해당 브라우저를 구동시킬 드라이버 또한 다운 받았다. 브라우저 버전과 드라이버의 버전이 일치해야 한다.  Chrome 버전 확인     Chrome → 설정 → Chrome 정보 탭     Chrome 드라이버 다운ChromeDriver - WebDriver for Chrome - Downloads프로젝트의 폴더에 해당 드라이버를 넣어주자pip를 통해 python에서 Selenium을 쓸 수 있도록 설치하자  Selenium 설치pip install Selenium 크롤링 시작: 준비를 마쳤다면 본격적으로 크롤링을 시작해보자. Selenium 시작: 우선 Selenium으로 브라우저를 구동 시켜보자. 확장성을 고려하여 함수를 선언해 호출하자. 모든 코드는 python으로 작성되었다. 123456789101112131415161718192021from selenium import webdriverdef openBrowser(): driverOptions = webdriver. ChromeOptions() # driverOptions. add_argument('headless') # 브라우저를 띄우지 않고 실행. linux라면 필수.  # driverOptions. add_argument('disable-gpu') # GPU 사용 안하도록 설정 # driverOptions. add_argument('--no-sandbox') driverOptions. add_argument('lang=ko_KR') # 언어 설정 driverOptions. add_argument('--disable-dev-shm-usage') # 공유 메모리를 담당하는 디렉토리를 사용하지 않겠다는 의미이다.  driverOptions. add_argument('window-size=1920,1080') # 브라우저의 크기를 설정 driver = webdriver. Chrome('chromedriver', options=driverOptions)return driverdef crawling(): driver = openBrowser() .  .  .  driver. close()crawling()주석을 친 부분은 headless 모드로 구동시킬 때 필요한 option들이다. Linux와 같은 환경에서는 GUI를 지원하지 않기 때문에 headless 모드로 해줘야 한다. headless 모드를 사용하면 백그라운드로 실행되기 때문에 다른 작업과 병행할 수 있다. 그치만 내가 느낀 headless 모드의 단점 또한 있기 때문에 나는 되도록 headless 모드를 지양한다. 이는 아래에서 따로 설명하겠다. driver. close() 를 통해 driver를 종료할 수 있는데, 프로그램이 다 끝났다면 무조건 해주자. 컴퓨터에 종료되지 않은 chrome 들이 리소스를 잡아먹고 있을 수 있다.  페이지 접근: 위에서 설정해준대로 코드를 돌리면 브라우저가 잠깐 켜졌다가 꺼질 것이다. (아직 구현한 코드가 없어서)크롤링하는 페이지에 접근하려면 다음과 같이 하면 된다. 12345678def crawling(): driver = openBrowser() driver. get(url) driver. implicitly_wait(10) .  .  .  driver. close() driver. get(url)     브라우저를 해당 url에 접근하도록 한다.     driver. implicitly_wait(sec)     브라우저를 해당 페이지로 이동 시킨 후, 페이지가 로딩될 때 까지 최대 sec(초) 만큼 기다린다.    해당 페이지에 접근하자마자 요소를 긁어오려 한다면 아직 정보가 다 불려오지 않아 실패할 수 있다. 비동기 정보들을 올바르게 가져오기 위해선 꼭 위와 같이 기다려주자.    다양한 종류의 wait들이 존재한다. implicitly_wait() 은 유연한 wait을 제공하여 비교적 좋은 성능을 낼 수 있다.    한 번만 선언해도 모든 브라우저의 동작에 적용된다. 중복해서 사용하지 않아도 된다.    해당 페이지에서 찾으려는 요소 탐색: 개발자모드를 켜서 찾으려는 요소의 ID, CLASS, XPATH 등을 찾아오자. 본인이 가져오려는 정보에 맞춰 적절한 방식을 취하자. 탐색은 다음과 같이 구현된다. 12345678910111213from selenium. webdriver. common. by import Bydef crawling(): driver = openBrowser() driver. get(url) driver. implicitly_wait(10) targetList = driver. find_elements(By. CLASS_NAME, 클래스 이름 ) # targetList = driver. find_elements(By. ID, ID 이름 ) # targetList = driver. find_elements(By. TAG_NAME, 태그 이름 ) # targetList = driver. find_elements(By. XPATH, XPATH ) driver. close()find_elements()는 조건에 맞는 모든 요소들을 배열 형식으로 가져온다. 따라서 특정 Link를 불러오려고 할 때, find_elements(By. TAG_NAME, “a”) 와 같은 식으로 하다간 해당 페이지의 모든 a 태그를 불러올 것이다. 조금 더 구체적인 방식으로 원하는 요소만 골라보자. XPATH를 활용해도 되고 다음과 같이 여러번 물려서 사용할 수도 있다. 12target = driver. find_element(By. CLASS_NAME, 클래스 이름 ) # 예시를 위해 find_element를 통해 하나만 불러왔다. link = target. find_element(By. TAG_NAME,  a ). get_attribute( href ) target의 하위 요소들을 탐색하여 a 태그 요소를 찾고, 해당 요소의 href 속성값을 불러와 원하는 link를 불러올 수 있다. Selenium의 문법은 구글링하면 잘 나와있다. 참고해보자.  Multi-Processing: 사실 Multi-Processing 까지 해야할 필요는 없을 수 있다. 그러나 회사 규모의 큰 집단에서 다루는 데이터들은 보통 양이 많다. 이전에 받은 크롤링 업무에서 처리해야할 데이터가 약 2만 개 정도였다. Selenium 으로 페이지 이동을 하면서 한 데이터를 처리하는데 10~30초 정도 걸렸는데, 싱글 쓰레드로 2만 개 정도를 계산해보니 950 시간 정도가 걸렸던 것 같다. Multi-Processing이 간절히 필요했다 Multiprocessing: 파이썬에선 multiprocessing 라이브러리가 있으며 다음과 같이 쉽게 일을 분배할 수 있다. 123456789101112131415161718import multiprocessingif __name__ == '__main__': works = get_count( 처리할 데이터 수 ,  쓰레드 수 ) # 전체 데이터를 쓰레드 수에 맞게 분배 manager = multiprocessing. Manager() # 쓰레드간 메모리 공유를 위한 manager returnList = manager. list() # 각 쓰레드가 각자한 일을 returnList에 append for count in works: # crawling 함수를 수행할 process 생성  p = multiprocessing. Process(target=crawling, args=(returnList))  process. append(p)  p. start() # process 시작 for p in process:  p. join() # process가 종료될 때 까지 기다린다. 해주지 않고 프로그램이 종료되면 좀비 프로세스가 생길 수 있다. 	. 	. 	. if __name__ == ‘__main__’: 은 뭘까? 찾아봤더니 파이썬에서는 각 프로세스들이 내부적으로 __name__ 값을 갖는다. 즉 우리가 실행시킨 메인 프로그램은 __name__ 값으로 __main__ 값을 가지나, 그로 인해 생성된 자식 프로세스들은 __name__ == ‘__main__’ 가 False가 된다. 자식 프로세스들이 process를 무한정으로 재생산 하면 안되므로 위와 같이 보호(?) 해주자. 본인의 크롤링 작업과 환경에 맞게 알맞게 multi-processing을 해주자!필자는 8개의 쓰레드 까지는 효율이 잘 나왔으나, 16개로 쓰레드를 올리니 효율이 극 나빠졌다.  16 works / 8 workers : 4분 * 2 = 8분 16 works / 16 workers : 12분학교에서 C로 multi-processing 프로젝트를 했을 때는 32, 64개 정도의 worker process들을 생성하는 것이 sweet spot이었던 것 같은데, 네트워크 탓인지 Selenium이나 chrome의 탓인지 8개가 최고효율이었다. 그렇게 window server를 4개 파서 약 2만 개의 데이터를 660분 정도에 처리할 수 있었다. 950 시간 → 11 시간 트러블 슈팅: 크롤링을 하면서 다양한 이슈들이 있었다. Google에 은근 Selenium에 관한 정보들이 파편화 되어 있고 명확하게 없어서 기록해보기로 했다.  분명 개발자 도구에서는 보이는 데 find 가 안될 때 : iframe: 네이버 카페에 필요한 데이터가 있어 크롤링한 적이 있다. 게시글 목록을 불러오려 했는데 자꾸 빈 배열이 반환되었다. 내가 요소를 잘못 검색한 것인가 해서 find_elements() 로 상위 요소들을 한 depth씩 타고 올라갔다. 그러자 특정 부분에 변곡점(?)이 있었는데, 그게 iframe 태그였다.  iframe 이란?: MDN : 인라인 프레임 요소 현재의 HTML 내에 다른 HTML 페이지를 inline으로 삽입할 수 있도록 도와주는 Tag이다. 네이버 카페의 게시글 목록 부분은 iframe 태그로 다른 HTML을 불러와 내장시킨 구조였다. 즉 해당 부분은 다른 페이지라고 볼 수 있는 것이다.  Selenium에서 iframe 페이지를 접근 하는 법: 다음과 같이 iframe 페이지에 driver를 접근시킬 수 있다. 123def switchToIframeById(iframeId): iframe = driver. find_element(By. ID, iframeId) driver. switch_to. frame(iframe)이 후 driver에서 find_elements() 를 통해 하위 요소들을 탐색할 수 있다.  분명 개발자 도구에서는 보이는 데 find가 안될 때 2 : window-size: 네이버 호텔 페이지에서 Selenium을 써본 적이 있었다.   원하는 호텔과 날짜를 선택하여 검색한 후 가격 비교 탭의 회사별 상품 목록들을 보고 예약 버튼을 누르도록했는데 예약 버튼이 눌리지 않았다. 개발자 도구에서도 보이고 내 눈에도 보이는 데 Selenium이 이를 가져오지 못했다. 혹시 Selenium 탓인가 해서 BeautifulSoup을 통해 시도했는데, 이 또한 실패했다. 이걸로 1,2 시간은 삽질했으려나, 개발자 도구를 아래에서 옆으로 옮기다가 답을 알아냈다.  개발자 도구를 더 늘렸더니 예약 버튼이 사라졌다.  네이버 호텔 페이지의 예약 버튼은 반응형으로 페이지의 크기에 따라 생성되는 방식이었나보다. 즉 브라우저가 작게 띄워져 있거나 headless 모드로 실행되었다면 해당 요소를 찾을 수 없다.  Selenium의 브라우저 크기 조절: 아까의 driver options들을 보자 123456789101112from selenium import webdriverdef openBrowser(): driverOptions = webdriver. ChromeOptions() # driverOptions. add_argument('headless') # 브라우저를 띄우지 않고 실행. linux라면 필수.  # driverOptions. add_argument('disable-gpu') # GPU 사용 안하도록 설정 # driverOptions. add_argument('--no-sandbox') # 공유 메모리를 담당하는 디렉토리를 사용하지 않겠다는 의미이다.  driverOptions. add_argument('lang=ko_KR') # 언어 설정 driverOptions. add_argument('--disable-dev-shm-usage') # 공유 메모리를 담당하는 디렉토리를 사용하지 않겠다는 의미이다.  driverOptions. add_argument('window-size=1920,1080') # 브라우저의 크기를 설정 driver = webdriver. Chrome('chromedriver', options=driverOptions)return driver글 앞 부분에서 나는 되도록 headless를 지양한다고 했는데, 이는 이런 이유에서였다. 만약 headless를 해서 잘 나온다면 상관없지만, 잘 안된다면 headless 모드를 해제하고 window-size를 조절해보자.  🔧 headless 모드여도 window-size를 조절하면 위와 같은 상황에서 원하는 요소에 접근할 수 있다고 한다.  다양한 크기 조절 options  크기 지정     add_argument('--window-size= x, y')    최대화     add_argument('--start-maximized')    풀스크린 (F11)     add_argument('--start-fullscreen')    참조MDN : 인라인 프레임 요소 "
    }, {
    "id": 5,
    "url": "http://localhost:4000/nestjs-handle-disconnect/",
    "title": "[Nestjs] Socket Server에서 disconnect 감지하기",
    "body": "2022/12/24 - 부스트캠프에서 팀원들과 SleepyWoods라는 실시간 WebSocket 서비스를 만들었을 때, Socket. io를 사용했었다. 이번 글에서는 간단하게 클라이언트의 disconnect를 감지하는 부분을 구현해보자. HandleDisconnect: Nest. js에선 Socket Server를 구현할 때, 주로 다음과 같이 SocketGateWay를 구성한다. 123456789101112export class SocketGateway implements OnGatewayConnection, OnGatewayDisconnect { @WebSocketServer() server: Server; public handleConnection(client: Socket): void {  // 클라이언트가 접속되었을 때, 할 일 } public handleDisconnect(client: Socket): void {  // 클라이언트가 접속 해제되었을 때, 할 일 }}SocketGateway는 OnGatewayConnection와 OnGatewayDisconnect를 상속함으로써, 필수적으로 handleConnection과 handleDisconnect를 메소드로 지니게 된다. 여기서 클라이언트가 일반적인 접속 해제를 할 경우 대부분은 handleDisconnect로 이를 감지하고, 처리해줄 수 있다.  HandleDisconnect는 모든 disconnect을 감지할까?: 같이 Socket Server를 구성하던 피어와 실험해본 결과, handleDisconnect는 모든 disconnect를 감지하지 못한다. 다음과 같은 예외 상황이 있을 수 있다. ⚠️ 클라이언트가 비정상적인 종료를 했을 경우  브라우저의 강제 종료가 일어났을 때, 노트북의 배터리가 다 되어 노트북 자체가 강제 종료 되었을 때,위의 상황 말고도, 우리가 테스트해보지 못한 많은 예외 상황들이 있을 수 있다. 만약 disconnect를 감지하지 않아도 되는 서비스라면 모르겠지만, 우리 서비스에선 disconnect 시에 필수적인 로직이 있어 이 점이 중요했다. 1234public handleDisconnect(client: sleepySocket): void {  // 다른 유저들에게 해당 유저가 로그아웃 했다는 정보 전달  // 해당 유저의 그 날의 활동량을 기록} PingInterval과 pingTimeout: Nest. js 에서 SocketGateway를 구성할때, @WebSocketGateway 데코레이터를 통해, WebSocket에 option값을 넣어줄 수 있다. 다음과 같이 SocketGateway를 수정했다. 12345678910111213141516@WebSocketGateway({ pingInterval: 5000, pingTimeout: 3000})export class SocketGateway implements OnGatewayConnection, OnGatewayDisconnect { @WebSocketServer() server: Server; public handleConnection(client: Socket): void {  // 클라이언트가 접속되었을 때, 할 일 } public handleDisconnect(client: Socket): void {  // 클라이언트가 접속 해제되었을 때, 할 일 }}위의 두 가지 option들을 통해 heartbeat를 설정할 수 있는데, 이는 connection이 유효한 지 주기적으로 확인하는 과정이라 볼 수 있다. 서버는 pingInterval마다 connection을 확인하고, 마지막 요청으로부터 pingTimeout 시간 동안 응답이 없다면 클라이언트가 죽은 것으로 판단 해 disconnect 시킨다. (위의 예시에서는 5초마다 확인을 하며, 마지막 요청에서 3초간 응답이 없었으면 연결이 해제되었다고 판단한다. ) 이를 통해 클라이언트가 예기치 못한 접속 종료를 하더라도, 서버에서 이를 잡아낼 수 있다. 아래의 Socket. io 도큐먼트에서 조금 더 자세한 정보를 확인할 수 있다.  참조: Server options "
    }, {
    "id": 6,
    "url": "http://localhost:4000/nestjs-static-module/",
    "title": "[Nestjs] 정적 모듈에서의 환경변수 사용",
    "body": "2022/12/23 - NestJS에서는 dotenv 등의 외부 라이브러리가 아닌 내장된 ConfigModule를 통해 환경 변수를 접근할 수 있도록 해주는데. . env 파일을 삽입해두면 하위 모듈에서 이를 process. env 식으로 접근하여 환경 변수를 사용할 수 있다. 여기에 TypeORM을 연동하려고 다음과 같이 AppModule 을 구성했다. 123456789101112131415161718// app. module. tsimport { Module } from  @nestjs/common ;import { ConfigModule } from  @nestjs/config ;import { TypeOrmModule } from  @nestjs/typeorm ;import { typeORMConfig } from  . /configs/typeorm. config ;import { User } from  . /user/user. entity ;import { UserModule } from  . /user/user. module ;@Module({ imports: [  ConfigModule. forRoot({ isGlobal: true }),  TypeOrmModule. forRoot(typeORMConfig),  UserModule ], controllers: [], providers: []})export class AppModule {}1234567891011121314// typeorm. config. tsimport { TypeOrmModuleOptions } from  @nestjs/typeorm ;import { User } from  . . /user/user. entity ;export const typeORMConfig: TypeOrmModuleOptions = { type:  postgres , host:  localhost , port: 5432, username: process. env. DB_USERNAME, password: process. env. DB_PASSWORD, database: process. env. DB_ID, entities: [User], synchronize: true};그러나 이 때, 오류가 발생한다. 환경 변수 DB_ID 값을 이상한 값으로 가져와서 DB 연동에 실패하는 오류가 자꾸 생겼었다. 알아본 결과 그 이유는 다음과 같았다.  모듈은 정적으로 만들어진다. Nest에서의 configModule은 정적이다. 그래서 안 된다. 무슨 말이냐면, controller나 service처럼, Module들로 인해 모든 application이 만들어진 다음에야 configModule을 사용할 수 있다는 것이다. module의 생성 시점에는 configModule을 사용할 수 없다. (출처 : Nest. js에 ConfigModule 설정) 💡 Module의 생성 시점에는 configModule을 사용할 수 없다. 모듈을 동적으로 만들자: 아래와 같이 ConfigModule과 다른 Module들이 생성된 후에, 해당 환경 변수를 조회하도록 순서를 강제해주자. 123456789101112131415161718192021222324252627import { Module } from  @nestjs/common ;import { ConfigModule } from  @nestjs/config ;import { TypeOrmModule } from  @nestjs/typeorm ;import { User } from  . /user/user. entity ;import { UserModule } from  . /user/user. module ;@Module({ imports: [  ConfigModule. forRoot({ isGlobal: true }),  TypeOrmModule. forRootAsync({   useFactory: () =&gt; ({    type:  postgres ,    host: process. env. DB_HOST,    port: 5432,    username: process. env. DB_ID,    password: process. env. DB_PASSWORD,    database: process. env. DB_NAME,    entities: [User],    synchronize: true   })  }),  UserModule ], controllers: [], providers: []})export class AppModule {} 모듈을 동적으로 만들자 2: 아래의 방식은 JwtModule에 환경변수 JWT_SECRET_KEY를 주입하다가 알아낸 방식이다. 12345678910111213141516171819202122// AppModule 에 JWTModule 추가하기. import { Module } from  @nestjs/common ;import { ConfigModule } from  @nestjs/config ;import { JwtModule } from  @nestjs/jwt ;import { UserModule } from  . /user/user. module ;@Module({ imports: [  ConfigModule. forRoot({ isGlobal: true }),  JwtModule. registerAsync({   inject: [ConfigService],   useFactory: (config: ConfigService) =&gt; ({    secret:    + config. get&lt;string&gt;( JWT_SECRET_KEY ),    signOptions: { expiresIn:  86400s  }   })  }),  UserModule ], controllers: [], providers: []})export class AppModule {}JwtModule의 등록 부분에서 secret 부분을 자세히 보면 환경 변수를 불러오고 빈 문자열‘’을 더해준다. 단순히 가져온 토큰을 string 형식으로 형 변환 시키기 위함이 아닌, 해당 부분에 강제로 연산을 부여해주어 해당 부분의 연산을 Module이 모두 생성된 이후로 미루게 하는 방법이다. 그렇게 된다면, 해당 시기엔ConfigModule이 생성된 이후의 시점이므로 에러가 발생하지 않고 환경 변수를 잘 불러온다. 매우 기발하다! 개선점: 위와 같은 방식에서 가장 불편한(?) 점은 Module 부분에 TypeOrmModuleOptions 같은 부분이 일일이 적힌다는 것이다. 나중에 module에 내용이 많아진다면, 코드가 지저분해질 수 있다. 해당 부분을 해결할 순 없을까? 참조: Nest. js에 ConfigModule 설정 "
    }, {
    "id": 7,
    "url": "http://localhost:4000/boostcamp-7-post/",
    "title": "부스트캠프 웹·모바일 7기 회고",
    "body": "2022/12/21 - 약 5달간의 여정이 끝났다. 웹에 관해 아는 것이 전혀 없던 내가 어떻게 두려움도 없이 이 곳에 올 선택을 할 수 있었을까. 부스트캠프에 지원하기로 했던 결심은 내 개발 인생에서 가장 크고 긍정적인 변화를 줬다.  부스트캠프 이전의 나: 나는 그냥 컴퓨터공학과를 다니던 평범한 전공생이었다. 컴퓨터공학이 좋아서 오긴 했으나, 고등학교 생활의 보상심리였을까 대학교에서의 공부를 그닥 밀도 있게 하지는 않았다. 즐겁게 공부하긴 했지만 사실 열을 다해서 하진 않았으며, 딱 뒤쳐지지 않은 정도였다. 그렇게 무기력하게 학교를 다니다 진로를 정해야할 때가 되었고, System Programming수업과 DB수업을 흥미롭게 듣던 나는 얼떨결에 백엔드 개발자가 되기로 결심했다.  우선 웹에 대해서 배워보자! 부스트캠프 과정의 나: 우선 웹에 대해서 공부하기로 하고 부스트캠프에 지원했다. 두 차례의 코딩 테스트를 통해 선발이 되었는데, 이는 다행히도 1,2월쯤 들었던 삼성전자 DX부문 동계 대학생 S/W 알고리즘 역량 강화 특강의 덕이 컸다. 이 후 챌린지 기간을 거치며 기초 CS 지식 심화학습 및 분야별 도메인 지식 학습을 진행했는데, 이 과정이 근래에 가장 힘들었던 기간인 것 같다. 챌린지: 2022. 07. 18 ~ 08. 12 챌린지 기간엔 웹을 공부하기 이전에 관련 도메인 지식을 학습했다. 어떤 건 학교에서 배울 수 있는 내용이었지만, 학교에서 배울 수 없던 것들 또한 있었다. 무기력함이 떨쳐질 정도로 재미있었으며, 별개로 나의 부족한 점을 채워나가느라 이 기간 동안 거의 매일을 새벽 4,5시쯤 잤다. 이 시기에 나는 javascript를 처음 써봤다. 내 개발 인생 99%를 C와 python만 써오다가 javascript를 처음 써봤는데, 비동기라는 개념이 나를 엄청 괴롭혔다. 절차지향식으로 알고리즘 공부만 하던 내게는 당시에 익숙하지 않은 개념이었으며 코드적으로 적응하기가 너무 어려웠다.  🙀 사실 비동기 처리는 네트워크 및 자원을 다루는 개발에 있어 굉장히 당연하고 중요한 부분이다. 익숙해진 지금은 너무 당연한 것들이 당시엔 왜 저리 어려웠는지…. 기록과 공유의 중요성: 부스트캠프를 진행하는 동안 많은 미션들을 해결하기 위해 깊게 공부하거나 코드를 짜는 시간도 있었지만, 해당 과정에서 얻은 지식 및 경험들을 기록하고 공유하는 습관을 들이게 되었다. 이 또한 프로그램의 취지 중 하나였지만 실제로 다양한 사람들과 지식 공유를 하고코드 리뷰를 받다보면 스스로 성장하고 있음을 느꼈다. 또한 기술 공유를 앞두고 있을 때는 평소보다 조금 더 깊고 엄격하게 공부를 하다보니 스스로에게 큰 도움이 되었다.  멤버십: 2022. 08. 31~12. 16 내 밤샘 노력이 결국 멤버십 합격으로 결실을 맺었다.  챌린지 때 너무 두들겨 맞았어서 멤버십 때는 좀 강해져서 돌아가고 싶었다. 그래서 진~짜 안 읽던 책도 몇권 사고 모던 자바스크립트 Deep Dive를 열심히 읽고 정리했다. 난 내가 강해졌다고 생각했다. 그러나 한 주, 한 주 지나가며 지식이 많아질 수록 모르는 건 더 많아졌다. 알면 알수록 내 위치가 더 적나라하게 드러났다. 백엔드를 지망한다고 했으면서 프론트엔드를 지망하시는 분들 보다 서버에 대해 훨씬 무지했으며, 이런 내가 화가나고 부끄러웠다. 자신감이 떨어지다 보니 사람들과 지식 공유를 하는 과정에서 매우 소극적이게 변하고 참여하는 것을 두려워 했는데, 주기적으로 오는 동료들의 요청이 정말 두려웠다.  코드 리뷰 좀 해주실 수 있나요? 🙀🙀 초반 1주차~4주차 정도엔 자괴감에 빠져 살았다. 약간 축구선수가 공이 내게 오지 않았으면 하는 슬럼프에 빠진 느낌… 이를 극복하기 까지는 꽤 많은 밤과 동료들이 필요했다. 중간에 동료들과 오순도순이라는 팀을 만들어 SleepyWoods라는 웹 서비스를 개발했는데, 이 동료들 덕분에 정말 많이 성장한 것 같다. 지금은 내가 당장은 모르는 것이어도 시간만 들이면 뭐든 할 수 있다는 자신감이 생겼다. SleepyWoods 방문하기 부스트캠프 이후의 나: 부스트캠프의 슬로건은 다음과 같다.  개발자의 지속 가능한 성장을 위한 학습 커뮤니티 처음엔 위의 뜻을 잘 이해하지 못했다. 사전적인 의미 이상으로 와닿지는 않는 문장이었다. 그러나 부스트캠프를 수료한 지금은 저 문장이 지난 5달을 완벽히 요약한 문장이라고 생각된다. 학습은 혼자 집에서도 할 수 있다. 이제와서 남은 것이 무엇이냐 생각해보면, 지식이 아니라 언제든 같이 지식을 학습할 수 있는 커뮤니티 아니었을까. 열심히 하는 사람들 사이에 있으면 나도 자극받는다. 운동을 잘 안 가는 나도 막상 헬스장에 가면 열심히 하는 그런 느낌? 정말 많은 것을 느낀 경험이었으며, 만약 누군가가 추천하는 지 묻는다면 나는 무조건 추천한다. 특히 본인이 무기력함에 빠졌을 때는 더욱!지속 성장 가능한 개발자가 되기 위해 몇 가지 나만의 rule을 정해보자 1. 혼자 앓지 말고, 주변 동료들을 잘 활용하자. 2. 기술 공유를 두려워하지 말고, 뭐든지 문서화하자. 3. 관성적으로 움직이지 말고, 계속 스스로 불편한 질문을 던져보자. 4. 다른 사람과 나를 비교하고, 자책하지 말자. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});